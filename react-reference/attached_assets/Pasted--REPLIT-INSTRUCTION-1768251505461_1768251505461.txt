================================================================================
REPLIT INSTRUCTION: Handle Structured JSON Responses
================================================================================

CONTEXT:
--------
The backend now returns structured JSON responses from Menu/Analytics agents
instead of raw Pydantic repr format. The frontend needs to detect and render
these responses nicely.

BEFORE (broken):
  entity='categories' task='List all...' tools_used=['...']

AFTER (fixed - valid JSON):
  {"entity": "categories", "task": "List all menu categories", "ok": true, ...}


================================================================================
TASK: Detect and render structured JSON responses
================================================================================

The backend sends structured responses that start with `{` and contain `"agent":`.
These should be parsed and rendered as formatted content instead of raw JSON.


--------------------------------------------------------------------------------
STEP 1: Add helper function to detect structured responses
--------------------------------------------------------------------------------

Add this utility function (e.g., in src/utils/message-utils.ts or inline):

```typescript
export const isStructuredResponse = (content: string): boolean => {
  if (!content || typeof content !== 'string') return false;
  const trimmed = content.trim();
  return trimmed.startsWith('{') && trimmed.includes('"agent":');
};
```


--------------------------------------------------------------------------------
STEP 2: Add TypeScript interfaces for structured responses
--------------------------------------------------------------------------------

Add these types (e.g., in src/types/labeeb.ts):

```typescript
interface WriteResult {
  entity: string;
  op: 'LIST' | 'CREATE' | 'UPDATE' | 'DELETE';
  ids: string[];
  ok: boolean;
  verified?: boolean | null;
  note: string;
  context?: string | null;  // Contains markdown tables for LIST operations
}

interface StructuredAgentResponse {
  entity: string;
  task: string;
  tools_used: string[];
  ok: boolean;
  verified?: boolean | null;
  summary: string;
  type: 'LIST' | 'CREATE' | 'UPDATE' | 'DELETE' | 'REPORT';
  agent: 'menu' | 'analytics';
  result?: WriteResult[];
  context?: string | null;
}
```


--------------------------------------------------------------------------------
STEP 3: Create StructuredResponse component
--------------------------------------------------------------------------------

Create a new component (e.g., src/components/StructuredResponse.tsx):

```tsx
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

interface WriteResult {
  entity: string;
  op: string;
  ok: boolean;
  note: string;
  context?: string | null;
}

interface StructuredResponseProps {
  data: {
    summary: string;
    agent: string;
    ok: boolean;
    result?: WriteResult[];
    context?: string | null;
  };
}

export function StructuredResponse({ data }: StructuredResponseProps) {
  const { summary, agent, ok, result, context } = data;

  return (
    <div className="space-y-4">
      {/* Summary banner */}
      <div className={`p-3 rounded-lg ${ok ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'}`}>
        <div className="flex items-center gap-2">
          <span className={`text-sm font-medium px-2 py-0.5 rounded ${agent === 'menu' ? 'bg-blue-100 text-blue-700' : 'bg-purple-100 text-purple-700'}`}>
            {agent === 'menu' ? 'Menu' : 'Analytics'}
          </span>
          <span className="font-medium text-gray-800">{summary}</span>
        </div>
      </div>

      {/* Render context if present (contains markdown tables) */}
      {context && (
        <div className="prose prose-sm max-w-none">
          <ReactMarkdown remarkPlugins={[remarkGfm]}>
            {context}
          </ReactMarkdown>
        </div>
      )}

      {/* Render results */}
      {result?.map((r, i) => (
        <div key={i} className="border-l-2 border-gray-200 pl-4">
          {r.context ? (
            <div className="prose prose-sm max-w-none">
              <ReactMarkdown remarkPlugins={[remarkGfm]}>
                {r.context}
              </ReactMarkdown>
            </div>
          ) : r.note ? (
            <p className="text-gray-600">{r.note}</p>
          ) : null}
        </div>
      ))}
    </div>
  );
}
```


--------------------------------------------------------------------------------
STEP 4: Update message rendering to use StructuredResponse
--------------------------------------------------------------------------------

In your message display component (e.g., where you render assistant messages),
add logic to detect and render structured responses:

```tsx
import { isStructuredResponse } from '@/utils/message-utils';
import { StructuredResponse } from '@/components/StructuredResponse';

// In your message rendering logic:
function renderMessageContent(content: string) {
  // Check if this is a structured JSON response from an agent
  if (isStructuredResponse(content)) {
    try {
      const data = JSON.parse(content);
      return <StructuredResponse data={data} />;
    } catch (e) {
      // JSON parse failed, fall through to default rendering
      console.warn('Failed to parse structured response:', e);
    }
  }

  // Default: render as markdown
  return (
    <ReactMarkdown remarkPlugins={[remarkGfm]}>
      {content}
    </ReactMarkdown>
  );
}
```


--------------------------------------------------------------------------------
STEP 5: Install required dependencies (if not already installed)
--------------------------------------------------------------------------------

```bash
npm install react-markdown remark-gfm
```


================================================================================
TESTING
================================================================================

1. Send a message like "what categories do I have?" or "list my products"
2. The response should now show:
   - A colored banner with the agent type (Menu/Analytics) and summary
   - Nicely formatted markdown tables from the context field
   - Instead of raw JSON text


================================================================================
JSON STRUCTURE REFERENCE
================================================================================

Example response from backend:

{
  "entity": "categories",
  "task": "List all menu categories",
  "tools_used": ["Foodics___list_categories_detailed"],
  "ok": true,
  "verified": null,
  "summary": "Retrieved 100 total categories (page 1 of 2)",
  "type": "LIST",
  "agent": "menu",
  "result": [
    {
      "entity": "category",
      "op": "LIST",
      "ids": [],
      "ok": true,
      "verified": null,
      "note": "Listed 50 categories on page 1 of 2",
      "context": "## Your Menu Categories\n\n| Name | Reference | Status |\n|------|-----------|--------|\n| Food Mark1 | cat-10 | Deleted |\n..."
    }
  ],
  "context": null
}

Key fields to display:
- summary: One-line description of what happened
- agent: "menu" or "analytics" (use for color coding)
- ok: true/false (use for success/error styling)
- result[].context: Contains markdown tables (render with ReactMarkdown)
- result[].note: Short text when context is not available


================================================================================
