# Labeeb UI Integration Guide for Replit

## Project Overview

**Labeeb** is an AI-powered restaurant management assistant built with multi-agent architecture. The backend is deployed on AWS Bedrock AgentCore (not LangGraph Platform), and we need to build a frontend UI to interact with it.

**Key Architecture Decisions:**
- Backend: AWS Bedrock AgentCore (WebSocket + HTTP API)
- Frontend: React + TypeScript (using Orbit as base)
- Previous prototype used LangGraph Platform which had built-in Agent Chat UI

---

## Part 1: Current State Analysis

### 1.1 Backend API (AgentCore)

The Labeeb backend exposes two endpoints:

**HTTP Endpoint (`POST /invocations`):**
```typescript
// Request
{
  prompt: string;           // User message
  session_id?: string;      // Conversation thread (auto-generated if not provided)
  tenant_id?: string;       // From JWT if not provided
  role?: string;            // From JWT if not provided
}

// Response
{
  response: string;         // Agent's response
  session_id: string;       // Session ID for continuation (STORE THIS!)
}

// Session Flow:
// 1. First message: Omit session_id, server generates one (40 chars)
// 2. Server returns session_id in response
// 3. Client MUST store this session_id
// 4. Subsequent messages: Include stored session_id to continue conversation
```

**WebSocket Endpoint (`/ws`):**
```typescript
// Client → Server Messages
{ type: "message", content: string, session_id?: string }  // session_id auto-generated if omitted
{ type: "approve", session_id: string, decision: "approve" | "reject", reason?: string }
{ type: "ping" }

// Server → Client Messages
{ type: "token", content: string }           // Streaming text chunk
{ type: "interrupt", session_id: string, action: string, tool_name: string, preview: string, arguments: object }
{ type: "complete", session_id: string }     // IMPORTANT: Extract session_id here for future messages!
{ type: "approval_ack", session_id: string, decision: string }  // "approve" or "reject"
{ type: "error", message: string, pending_tool?: string }  // pending_tool set if blocked by HITL
{ type: "pong" }

// WebSocket Session Flow:
// 1. First message: { type: "message", content: "Hello" }  ← no session_id
// 2. Server streams tokens, then: { type: "complete", session_id: "session-abc123..." }
// 3. Client stores session_id from "complete" event
// 4. Next message: { type: "message", content: "Follow up", session_id: "session-abc123..." }
```

**Authentication:**
```typescript
Headers:
  Authorization: Bearer <cognito_access_token>
  X-User-Token: <cognito_id_token>  // Optional, preferred
```

### 1.2 Human-in-the-Loop (HITL) Flow

When the agent attempts a write operation (create/update/delete), it pauses and sends an interrupt:

```
1. User sends message: "Create a product called Latte, price 25 SAR"
2. Agent receives, starts processing
3. Agent reaches tool call: create_product({name: "Latte", price: 25})
4. Server sends interrupt event:
   {
     type: "interrupt",
     session_id: "abc123",
     action: "create_product",
     tool_name: "create_product",
     preview: "**Creating Product**\nName: Latte\nPrice: 25 SAR",
     arguments: { name: "Latte", price: 25 }
   }
5. UI shows confirmation modal to user
6. User clicks Approve/Reject
7. Client sends:
   { type: "approve", session_id: "abc123", decision: "approve" }
8. Server resumes agent execution
9. Server sends completion event with result
```

**Operations requiring HITL approval:**
- Menu: `create_product`, `update_product`, `delete_product`, `create_category`, `update_category`, `delete_category`, `create_modifier`, etc.
- Analytics: `create_customer`, `blacklist_customer`, `unblacklist_customer`

**IMPORTANT: Pending Approval Blocks New Messages**

If a session has a pending HITL approval, new messages are blocked until resolved:

```json
// User sends new message while approval pending
{ "type": "message", "content": "Do something else", "session_id": "abc123" }

// Server responds with error
{
  "type": "error",
  "message": "Pending approval required for 'create_product'. Please approve or reject before sending new messages.",
  "pending_tool": "create_product"
}
```

Frontend should:
1. Disable the input field while `interrupt` is pending
2. Show the approval modal prominently
3. If `error` with `pending_tool` received, remind user to approve/reject first

### 1.3 Agent System

```
Supervisor Agent (routes requests)
├── Menu Agent (41 MCP tools) - products, categories, combos, modifiers
├── Analytics Agent (10 MCP tools) - orders, customers, sales, loyalty
└── Market Research Agent (Tavily) - web search, competitive analysis
```

---

## Part 2: LangGraph Platform vs AgentCore API Differences

### 2.1 What LangGraph Platform Provided (we no longer use this)

```typescript
// LangGraph SDK
import { Client } from "@langchain/langgraph-sdk";

const client = new Client({ apiUrl, apiKey });
const thread = await client.threads.create();
const stream = client.runs.stream(thread.id, assistantId, {
  input: { messages: [...] },
  streamMode: "updates"
});

// Interrupt handling
await client.runs.resume(thread.id, runId, new Command({ resume: approvalValue }));
```

**LangGraph Platform features we used:**
- `client.threads.create()` - Thread management
- `client.runs.stream()` - Streaming responses
- Built-in interrupt/resume with `Command`
- Agent Chat UI support

### 2.2 AgentCore Equivalent (what we use now)

```typescript
// Custom WebSocket client (no SDK - we implement ourselves)
class LabeebClient {
  private ws: WebSocket;
  private sessionId: string;

  constructor(baseUrl: string, token: string) {
    this.ws = new WebSocket(`${baseUrl}/ws`);
    this.ws.onopen = () => {
      this.ws.send(JSON.stringify({ type: "auth", token }));
    };
  }

  sendMessage(content: string): void {
    this.ws.send(JSON.stringify({
      type: "message",
      content,
      session_id: this.sessionId
    }));
  }

  approve(decision: "approve" | "reject", reason?: string): void {
    this.ws.send(JSON.stringify({
      type: "approve",
      session_id: this.sessionId,
      decision,
      reason
    }));
  }

  onToken(handler: (content: string) => void): void { /* ... */ }
  onInterrupt(handler: (interrupt: InterruptEvent) => void): void { /* ... */ }
  onComplete(handler: (sessionId: string) => void): void { /* ... */ }
}
```

**Key Differences:**
| Feature | LangGraph Platform | AgentCore |
|---------|-------------------|-----------|
| Thread Management | `client.threads.create()` | Session ID in WebSocket message |
| Streaming | `client.runs.stream()` | WebSocket `{ type: "token" }` events |
| Interrupts | `Command({ resume: value })` | `{ type: "approve", decision }` |
| Auth | API Key | Cognito JWT |
| SDK | `@langchain/langgraph-sdk` | Custom WebSocket client |

---

## Part 3: Orbit Codebase Analysis

### 3.1 What Orbit Has (can reuse)

**UI Components:**
- Chat message feed with user/assistant bubbles
- Smart Actions panel with action cards
- Modal dialogs for multi-step workflows
- Tab-based navigation (Layout.tsx)
- Dark mode support
- Responsive sidebar
- Data visualization (Recharts)
- Form components (inputs, buttons, badges)

**API Patterns:**
- Axios service with interceptors (fraud-api.ts)
- TanStack Query for server state
- WebSocket for real-time updates (fraud alerts)

**Relevant Files:**
```
src/pages/OrbitAssistant.tsx  - Chat UI (1,513 lines) ⭐ Main template
src/pages/InventoryGuru.tsx   - Investigation workflow (has modal pattern)
src/services/fraud-api.ts     - API client pattern (525 lines)
src/hooks/useFraudDetection.ts - Custom hook pattern
src/components/ui/            - Base UI components
```

### 3.2 What Orbit Lacks (needs to be built)

1. **No persistent sessions** - Messages lost on refresh
2. **No LangGraph/AgentCore integration** - Uses mock responses
3. **No HITL confirmation UI** - Only investigation modals
4. **No streaming handler** - All responses atomic
5. **No thread history** - Single session in memory
6. **No JWT auth with Cognito** - Basic token storage

---

## Part 4: Implementation Tasks for Replit

### Task 1: Create Labeeb API Service

Create `src/services/labeeb-api.ts`:

```typescript
// Types
interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  isStreaming?: boolean;
}

interface InterruptEvent {
  session_id: string;
  action: string;
  tool_name: string;
  preview: string;
  arguments: Record<string, any>;
}

interface LabeebClientOptions {
  baseUrl: string;
  token: string;
  onToken?: (content: string) => void;
  onInterrupt?: (interrupt: InterruptEvent) => void;
  onComplete?: (sessionId: string) => void;
  onError?: (error: Error) => void;
}

// Service class
export class LabeebClient {
  private ws: WebSocket | null = null;
  private sessionId: string | null = null;
  private options: LabeebClientOptions;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  constructor(options: LabeebClientOptions) {
    this.options = options;
  }

  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(`${this.options.baseUrl}/ws`);

      this.ws.onopen = () => {
        this.reconnectAttempts = 0;
        resolve();
      };

      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      };

      this.ws.onerror = (error) => {
        this.options.onError?.(new Error('WebSocket error'));
        reject(error);
      };

      this.ws.onclose = () => {
        this.attemptReconnect();
      };
    });
  }

  private handleMessage(data: any): void {
    switch (data.type) {
      case 'token':
        this.options.onToken?.(data.content);
        break;
      case 'interrupt':
        this.sessionId = data.session_id;
        this.options.onInterrupt?.(data);
        break;
      case 'complete':
        this.sessionId = data.session_id;
        this.options.onComplete?.(data.session_id);
        break;
      case 'error':
        this.options.onError?.(new Error(data.message));
        break;
    }
  }

  sendMessage(content: string, sessionId?: string | null): void {
    if (!this.ws) throw new Error('Not connected');
    this.ws.send(JSON.stringify({
      type: 'message',
      content,
      session_id: sessionId || undefined  // Omit if null/undefined, server will generate
    }));
  }

  approve(decision: 'approve' | 'reject', reason?: string): void {
    if (!this.ws || !this.sessionId) throw new Error('No pending approval');
    this.ws.send(JSON.stringify({
      type: 'approve',
      session_id: this.sessionId,
      decision,
      reason
    }));
  }

  disconnect(): void {
    this.ws?.close();
    this.ws = null;
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => this.connect(), 1000 * this.reconnectAttempts);
    }
  }
}
```

### Task 2: Create useLabeeb Hook

Create `src/hooks/useLabeeb.ts`:

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { LabeebClient, InterruptEvent, Message } from '../services/labeeb-api';

interface UseLabeebOptions {
  baseUrl: string;
  token: string;
}

export function useLabeeb({ baseUrl, token }: UseLabeebOptions) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [pendingApproval, setPendingApproval] = useState<InterruptEvent | null>(null);
  const [streamingContent, setStreamingContent] = useState('');
  const [sessionId, setSessionId] = useState<string | null>(null);  // Track session!

  const clientRef = useRef<LabeebClient | null>(null);

  useEffect(() => {
    const client = new LabeebClient({
      baseUrl,
      token,
      onToken: (content) => {
        setStreamingContent(prev => prev + content);
      },
      onInterrupt: (interrupt) => {
        // Finalize streaming message before showing interrupt
        if (streamingContent) {
          setMessages(prev => [...prev, {
            id: `assistant-${Date.now()}`,
            role: 'assistant',
            content: streamingContent,
            timestamp: new Date()
          }]);
          setStreamingContent('');
        }
        setPendingApproval(interrupt);
        setIsLoading(false);
      },
      onComplete: (receivedSessionId) => {
        // IMPORTANT: Store session_id from server for future messages!
        setSessionId(receivedSessionId);

        // Finalize streaming message
        if (streamingContent) {
          setMessages(prev => [...prev, {
            id: `assistant-${Date.now()}`,
            role: 'assistant',
            content: streamingContent,
            timestamp: new Date()
          }]);
          setStreamingContent('');
        }
        setIsLoading(false);
      },
      onError: (error) => {
        console.error('Labeeb error:', error);
        setIsLoading(false);
      }
    });

    clientRef.current = client;
    client.connect().then(() => setIsConnected(true));

    return () => client.disconnect();
  }, [baseUrl, token]);

  const sendMessage = useCallback((content: string) => {
    if (!clientRef.current) return;

    // Add user message
    setMessages(prev => [...prev, {
      id: `user-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date()
    }]);

    setIsLoading(true);
    setStreamingContent('');
    // Pass sessionId to continue conversation (null for first message)
    clientRef.current.sendMessage(content, sessionId);
  }, [sessionId]);  // Depend on sessionId!

  const handleApproval = useCallback((decision: 'approve' | 'reject', reason?: string) => {
    if (!clientRef.current || !pendingApproval) return;

    // Add approval action to messages
    setMessages(prev => [...prev, {
      id: `action-${Date.now()}`,
      role: 'user',
      content: decision === 'approve'
        ? `✅ Approved: ${pendingApproval.action}`
        : `❌ Rejected: ${pendingApproval.action}${reason ? ` (${reason})` : ''}`,
      timestamp: new Date()
    }]);

    setIsLoading(true);
    clientRef.current.approve(decision, reason);
    setPendingApproval(null);
  }, [pendingApproval]);

  // Start a new chat (clears messages and session)
  const startNewChat = useCallback(() => {
    setSessionId(null);
    setMessages([]);
    setStreamingContent('');
  }, []);

  return {
    messages,
    isConnected,
    isLoading,
    pendingApproval,
    streamingContent,
    sessionId,         // Expose for UI (show session indicator)
    sendMessage,
    handleApproval,
    startNewChat       // For "New Chat" button
  };
}
```

### Task 3: Create HITL Approval Modal Component

Create `src/components/ApprovalModal.tsx`:

```typescript
import { Modal, Button, Card } from './ui';

interface ApprovalModalProps {
  isOpen: boolean;
  onApprove: () => void;
  onReject: (reason?: string) => void;
  action: string;
  toolName: string;
  preview: string;
  arguments: Record<string, any>;
}

export function ApprovalModal({
  isOpen,
  onApprove,
  onReject,
  action,
  toolName,
  preview,
  arguments: args
}: ApprovalModalProps) {
  const [rejectReason, setRejectReason] = useState('');
  const [showRejectForm, setShowRejectForm] = useState(false);

  return (
    <Modal isOpen={isOpen} onClose={() => {}}>
      <Card>
        <Card.Header>
          <Card.Title>Confirm Action</Card.Title>
          <Card.Description>
            The agent wants to perform the following action. Please review and approve or reject.
          </Card.Description>
        </Card.Header>

        <Card.Content>
          <div className="space-y-4">
            {/* Action badge */}
            <div className="flex items-center gap-2">
              <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded text-sm font-medium">
                {toolName}
              </span>
            </div>

            {/* Preview */}
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <pre className="whitespace-pre-wrap text-sm">
                {preview}
              </pre>
            </div>

            {/* Arguments detail */}
            <details className="text-sm">
              <summary className="cursor-pointer text-gray-600">
                View raw arguments
              </summary>
              <pre className="mt-2 p-2 bg-gray-100 rounded overflow-auto">
                {JSON.stringify(args, null, 2)}
              </pre>
            </details>

            {/* Reject reason form */}
            {showRejectForm && (
              <div>
                <label className="block text-sm font-medium mb-1">
                  Rejection reason (optional)
                </label>
                <textarea
                  value={rejectReason}
                  onChange={(e) => setRejectReason(e.target.value)}
                  className="w-full p-2 border rounded"
                  rows={2}
                  placeholder="Why are you rejecting this action?"
                />
              </div>
            )}
          </div>
        </Card.Content>

        <Card.Footer className="flex justify-end gap-3">
          {!showRejectForm ? (
            <>
              <Button variant="outline" onClick={() => setShowRejectForm(true)}>
                Reject
              </Button>
              <Button variant="primary" onClick={onApprove}>
                Approve
              </Button>
            </>
          ) : (
            <>
              <Button variant="ghost" onClick={() => setShowRejectForm(false)}>
                Back
              </Button>
              <Button variant="danger" onClick={() => onReject(rejectReason)}>
                Confirm Rejection
              </Button>
            </>
          )}
        </Card.Footer>
      </Card>
    </Modal>
  );
}
```

### Task 4: Modify OrbitAssistant for Real Agent Integration

Update `src/pages/OrbitAssistant.tsx`:

```typescript
import { useLabeeb } from '../hooks/useLabeeb';
import { ApprovalModal } from '../components/ApprovalModal';

export function OrbitAssistant() {
  const {
    messages,
    isConnected,
    isLoading,
    pendingApproval,
    streamingContent,
    sendMessage,
    handleApproval
  } = useLabeeb({
    baseUrl: import.meta.env.VITE_LABEEB_API_URL,
    token: localStorage.getItem('authToken') || ''
  });

  const [inputValue, setInputValue] = useState('');

  const handleSend = () => {
    if (!inputValue.trim() || isLoading) return;
    sendMessage(inputValue.trim());
    setInputValue('');
  };

  return (
    <div className="flex flex-col h-full">
      {/* Connection status */}
      <div className="p-2 border-b flex items-center gap-2">
        <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
        <span className="text-sm text-gray-600">
          {isConnected ? 'Connected' : 'Disconnected'}
        </span>
      </div>

      {/* Message feed */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <div className={`max-w-[80%] p-3 rounded-lg ${
              msg.role === 'user'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 dark:bg-gray-800'
            }`}>
              <p className="whitespace-pre-wrap">{msg.content}</p>
              <span className="text-xs opacity-70">
                {msg.timestamp.toLocaleTimeString()}
              </span>
            </div>
          </div>
        ))}

        {/* Streaming message */}
        {streamingContent && (
          <div className="flex justify-start">
            <div className="max-w-[80%] p-3 rounded-lg bg-gray-100 dark:bg-gray-800">
              <p className="whitespace-pre-wrap">{streamingContent}</p>
              <span className="animate-pulse">▋</span>
            </div>
          </div>
        )}

        {/* Loading indicator */}
        {isLoading && !streamingContent && (
          <div className="flex justify-start">
            <div className="p-3 rounded-lg bg-gray-100">
              <span className="animate-pulse">Thinking...</span>
            </div>
          </div>
        )}
      </div>

      {/* Input area */}
      <div className="p-4 border-t">
        <div className="flex gap-2">
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSend()}
            placeholder="Ask Labeeb anything..."
            className="flex-1 p-3 border rounded-lg"
            disabled={isLoading || !isConnected}
          />
          <button
            onClick={handleSend}
            disabled={isLoading || !isConnected}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg disabled:opacity-50"
          >
            Send
          </button>
        </div>
      </div>

      {/* HITL Approval Modal */}
      <ApprovalModal
        isOpen={!!pendingApproval}
        onApprove={() => handleApproval('approve')}
        onReject={(reason) => handleApproval('reject', reason)}
        action={pendingApproval?.action || ''}
        toolName={pendingApproval?.tool_name || ''}
        preview={pendingApproval?.preview || ''}
        arguments={pendingApproval?.arguments || {}}
      />
    </div>
  );
}
```

### Task 5: Chat History Management (BACKEND API AVAILABLE)

**We now have a backend Chat API for storing chat history!** This means:
- Chat history persists across devices (not just localStorage)
- Admin dashboard can view user activity and metrics
- Proper user statistics tracking

#### Architecture (Updated)

```
┌─────────────────────────────────────────────────────────────────┐
│                        FRONTEND (Replit)                        │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │  Chat Sidebar   │  │  Active Chat    │  │  API Calls      │ │
│  │  - Past chats   │  │  - Messages     │  │  - GET /chats   │ │
│  │  - New chat btn │  │  - Input        │  │  - POST /chats  │ │
│  │  - Delete chat  │  │  - Streaming    │  │  - etc.         │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
           ┌──────────────────┴──────────────────┐
           ▼                                      ▼
┌──────────────────────────┐      ┌──────────────────────────────┐
│     AgentCore Runtime    │      │     User Management API      │
│  - Processes messages    │      │  - Chat CRUD operations      │
│  - Multi-turn sessions   │      │  - User statistics           │
│  - Returns session_id    │      │  - Admin dashboard           │
└──────────────────────────┘      └──────────────────────────────┘
```

#### Backend Chat API Endpoints

**Base URL:** `https://dqyhndp6d4.execute-api.eu-west-1.amazonaws.com/dev`

**Authentication:** Cognito JWT token in `Authorization: Bearer <token>` header

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/chats` | GET | List user's chats (paginated) |
| `/chats` | POST | Create new chat |
| `/chats/{sessionId}` | GET | Get chat with all messages |
| `/chats/{sessionId}` | PUT | Update chat (rename) |
| `/chats/{sessionId}` | DELETE | Delete chat |
| `/chats/{sessionId}/messages` | POST | Add message to chat |

#### API Examples

**List user's chats:**
```typescript
GET /chats?limit=50&lastKey=...

Response:
{
  "chats": [
    {
      "chatId": "session-abc123...",
      "title": "Help with menu pricing",
      "lastMessage": "I've updated the price to 25 SAR",
      "messageCount": 8,
      "createdAt": "2026-01-07T10:00:00Z",
      "updatedAt": "2026-01-07T10:15:00Z"
    }
  ],
  "lastKey": "..." // For pagination
}
```

**Create new chat:**
```typescript
POST /chats
{
  "sessionId": "session-abc123...",  // From AgentCore
  "title": "New Chat",               // Optional, auto-generated from first message
  "firstMessage": "Hello, help me..." // Optional
}

Response:
{
  "chatId": "session-abc123...",
  "title": "Hello, help me...",
  "createdAt": "2026-01-07T10:00:00Z"
}
```

**Get chat with messages:**
```typescript
GET /chats/session-abc123...

Response:
{
  "chatId": "session-abc123...",
  "title": "Help with menu pricing",
  "messages": [
    {
      "id": "user-1704621600000",
      "role": "user",
      "content": "What's the price of Americano?",
      "timestamp": "2026-01-07T10:00:00Z"
    },
    {
      "id": "assistant-1704621605000",
      "role": "assistant",
      "content": "The Americano is currently priced at 42 SAR.",
      "timestamp": "2026-01-07T10:00:05Z"
    }
  ],
  "messageCount": 2,
  "createdAt": "2026-01-07T10:00:00Z",
  "updatedAt": "2026-01-07T10:00:05Z"
}
```

**Add message to chat:**
```typescript
POST /chats/session-abc123.../messages
{
  "role": "user",        // user | assistant | system
  "content": "Update the price to 45 SAR",
  "metadata": {          // Optional
    "toolName": "update_product",
    "approved": true
  }
}

Response:
{
  "chatId": "session-abc123...",
  "messageId": "user-1704621700000",
  "timestamp": "2026-01-07T10:01:40Z"
}
```

**Update chat title:**
```typescript
PUT /chats/session-abc123...
{
  "title": "Menu Price Updates"
}
```

**Delete chat:**
```typescript
DELETE /chats/session-abc123...

Response:
{
  "deleted": true,
  "chatId": "session-abc123..."
}
```

#### Admin API Endpoints (Admin Role Required)

**Base URL:** `https://dqyhndp6d4.execute-api.eu-west-1.amazonaws.com/dev/admin`

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/users` | GET | List all users with stats |
| `/users/{userId}` | GET | Get user details |
| `/users/{userId}` | PUT | Update user status (block/unblock) |
| `/users/{userId}/chats` | GET | Get user's chat history |
| `/metrics` | GET | Get overall usage metrics |

#### DynamoDB Tables

| Table | Purpose |
|-------|---------|
| `labeeb-chats-dev` | Chat history (PK: UserId, SK: ChatId) |
| `labeeb-user-stats-dev` | User statistics and status |

#### Frontend Integration with Backend API

Create `src/services/chat-api.ts`:

```typescript
const CHAT_API_BASE = 'https://dqyhndp6d4.execute-api.eu-west-1.amazonaws.com/dev';

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: string;
  metadata?: {
    toolName?: string;
    approved?: boolean;
  };
}

export interface Chat {
  chatId: string;          // Same as session_id from AgentCore
  title: string;
  messages: ChatMessage[];
  messageCount: number;
  lastMessage: string;
  createdAt: string;
  updatedAt: string;
}

export interface ChatListResponse {
  chats: Chat[];
  lastKey: string | null;
}

class ChatApiService {
  private token: string = '';

  setToken(token: string): void {
    this.token = token;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const response = await fetch(`${CHAT_API_BASE}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || `API error: ${response.status}`);
    }

    return response.json();
  }

  // List user's chats (paginated)
  async getChats(limit = 50, lastKey?: string): Promise<ChatListResponse> {
    const params = new URLSearchParams({ limit: String(limit) });
    if (lastKey) params.set('lastKey', lastKey);
    return this.request(`/chats?${params}`);
  }

  // Get a specific chat with all messages
  async getChat(chatId: string): Promise<Chat> {
    return this.request(`/chats/${encodeURIComponent(chatId)}`);
  }

  // Create a new chat
  async createChat(sessionId: string, firstMessage?: string): Promise<Chat> {
    return this.request('/chats', {
      method: 'POST',
      body: JSON.stringify({
        sessionId,
        firstMessage,
      }),
    });
  }

  // Update chat (rename)
  async updateChat(chatId: string, title: string): Promise<void> {
    await this.request(`/chats/${encodeURIComponent(chatId)}`, {
      method: 'PUT',
      body: JSON.stringify({ title }),
    });
  }

  // Delete a chat
  async deleteChat(chatId: string): Promise<void> {
    await this.request(`/chats/${encodeURIComponent(chatId)}`, {
      method: 'DELETE',
    });
  }

  // Add message to chat
  async addMessage(
    chatId: string,
    role: 'user' | 'assistant' | 'system',
    content: string,
    metadata?: ChatMessage['metadata']
  ): Promise<{ messageId: string; timestamp: string }> {
    return this.request(`/chats/${encodeURIComponent(chatId)}/messages`, {
      method: 'POST',
      body: JSON.stringify({ role, content, metadata }),
    });
  }
}

export const chatApi = new ChatApiService();
```

**Note:** The API automatically creates chats and updates user statistics. You no longer need localStorage for chat persistence.

#### Create `src/components/ChatSidebar.tsx`:

```typescript
import { useState } from 'react';
import { Chat } from '../services/chat-api';
import { PlusIcon, TrashIcon, PencilIcon } from '@heroicons/react/24/outline';

interface ChatSidebarProps {
  chats: Chat[];
  activeChatId: string | null;
  onSelectChat: (chatId: string) => void;
  onNewChat: () => void;
  onDeleteChat: (chatId: string) => void;
  onRenameChat: (chatId: string, newTitle: string) => void;
  userEmail?: string;
}

export function ChatSidebar({
  chats,
  activeChatId,
  onSelectChat,
  onNewChat,
  onDeleteChat,
  onRenameChat,
  userEmail,
}: ChatSidebarProps) {
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editTitle, setEditTitle] = useState('');

  const handleStartEdit = (chat: Chat) => {
    setEditingId(chat.chatId);
    setEditTitle(chat.title);
  };

  const handleSaveEdit = (chatId: string) => {
    if (editTitle.trim()) {
      onRenameChat(chatId, editTitle.trim());
    }
    setEditingId(null);
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));

    if (days === 0) return 'Today';
    if (days === 1) return 'Yesterday';
    if (days < 7) return `${days} days ago`;
    return date.toLocaleDateString();
  };

  // Group chats by date
  const groupedChats = chats.reduce((groups, chat) => {
    const date = formatDate(chat.updatedAt);
    if (!groups[date]) groups[date] = [];
    groups[date].push(chat);
    return groups;
  }, {} as Record<string, Chat[]>);

  return (
    <div className="w-64 h-full bg-gray-900 text-white flex flex-col">
      {/* New Chat Button */}
      <div className="p-4">
        <button
          onClick={onNewChat}
          className="w-full flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition"
        >
          <PlusIcon className="w-5 h-5" />
          New Chat
        </button>
      </div>

      {/* Chat List */}
      <div className="flex-1 overflow-y-auto px-2">
        {Object.entries(groupedChats).map(([date, dateChats]) => (
          <div key={date} className="mb-4">
            <h3 className="px-2 py-1 text-xs text-gray-500 uppercase">{date}</h3>
            {dateChats.map((chat) => (
              <div
                key={chat.chatId}
                className={`group flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer mb-1 ${
                  chat.chatId === activeChatId
                    ? 'bg-gray-700'
                    : 'hover:bg-gray-800'
                }`}
                onClick={() => onSelectChat(chat.chatId)}
              >
                {editingId === chat.chatId ? (
                  <input
                    type="text"
                    value={editTitle}
                    onChange={(e) => setEditTitle(e.target.value)}
                    onBlur={() => handleSaveEdit(chat.chatId)}
                    onKeyDown={(e) => e.key === 'Enter' && handleSaveEdit(chat.chatId)}
                    className="flex-1 bg-gray-600 px-2 py-1 rounded text-sm"
                    autoFocus
                    onClick={(e) => e.stopPropagation()}
                  />
                ) : (
                  <>
                    <span className="flex-1 truncate text-sm">{chat.title}</span>
                    <div className="hidden group-hover:flex items-center gap-1">
                      <button
                        onClick={(e) => { e.stopPropagation(); handleStartEdit(chat); }}
                        className="p-1 hover:bg-gray-600 rounded"
                      >
                        <PencilIcon className="w-4 h-4" />
                      </button>
                      <button
                        onClick={(e) => { e.stopPropagation(); onDeleteChat(chat.chatId); }}
                        className="p-1 hover:bg-red-600 rounded"
                      >
                        <TrashIcon className="w-4 h-4" />
                      </button>
                    </div>
                  </>
                )}
              </div>
            ))}
          </div>
        ))}

        {chats.length === 0 && (
          <div className="text-center text-gray-500 py-8">
            No chats yet. Start a new conversation!
          </div>
        )}
      </div>

      {/* User Info / Settings */}
      <div className="p-4 border-t border-gray-700">
        <div className="text-sm text-gray-400 truncate">
          {userEmail || 'Anonymous'}
        </div>
      </div>
    </div>
  );
}
```

#### Update `src/hooks/useLabeeb.ts` to integrate with storage:

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { LabeebClient, InterruptEvent } from '../services/labeeb-api';
import { chatStorage, Chat, ChatMessage } from '../services/chat-storage';

interface UseLabeebOptions {
  baseUrl: string;
  token: string;
  userId: string;  // Required for storage namespacing
}

export function useLabeeb({ baseUrl, token, userId }: UseLabeebOptions) {
  // Chat list state
  const [chats, setChats] = useState<Chat[]>([]);
  const [activeChat, setActiveChat] = useState<Chat | null>(null);

  // Connection state
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [pendingApproval, setPendingApproval] = useState<InterruptEvent | null>(null);
  const [streamingContent, setStreamingContent] = useState('');

  const clientRef = useRef<LabeebClient | null>(null);

  // Load chats on mount
  useEffect(() => {
    const loadedChats = chatStorage.getChats(userId);
    setChats(loadedChats);

    const activeChatId = chatStorage.getActiveChat(userId);
    if (activeChatId) {
      const chat = loadedChats.find(c => c.id === activeChatId);
      if (chat) setActiveChat(chat);
    }
  }, [userId]);

  // WebSocket connection
  useEffect(() => {
    const client = new LabeebClient({
      baseUrl,
      token,
      onToken: (content) => {
        setStreamingContent(prev => prev + content);
      },
      onInterrupt: (interrupt) => {
        finalizeStreamingMessage();
        setPendingApproval(interrupt);
        setIsLoading(false);
      },
      onComplete: (sessionId) => {
        finalizeStreamingMessage();
        setIsLoading(false);

        // Update active chat with session ID if needed
        if (activeChat && !activeChat.id) {
          const updatedChat = { ...activeChat, id: sessionId };
          setActiveChat(updatedChat);
          chatStorage.updateChat(userId, sessionId, updatedChat);
          refreshChats();
        }
      },
      onError: (error) => {
        console.error('Labeeb error:', error);
        setIsLoading(false);
      }
    });

    clientRef.current = client;
    client.connect().then(() => setIsConnected(true));

    return () => client.disconnect();
  }, [baseUrl, token]);

  const finalizeStreamingMessage = () => {
    if (streamingContent && activeChat) {
      const message: ChatMessage = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: streamingContent,
        timestamp: new Date().toISOString(),
      };
      chatStorage.addMessage(userId, activeChat.id, message);
      refreshChats();
      setStreamingContent('');
    }
  };

  const refreshChats = () => {
    const updated = chatStorage.getChats(userId);
    setChats(updated);
    if (activeChat) {
      setActiveChat(updated.find(c => c.id === activeChat.id) || null);
    }
  };

  // Send message
  const sendMessage = useCallback((content: string) => {
    if (!clientRef.current || !content.trim()) return;

    let chatId = activeChat?.id;

    // Create new chat if none active
    if (!activeChat) {
      // We'll get session_id from server, use temp ID for now
      const tempId = `temp-${Date.now()}`;
      const newChat = chatStorage.createChat(userId, tempId, content);
      setActiveChat(newChat);
      chatId = tempId;
    }

    // Add user message to storage
    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date().toISOString(),
    };
    chatStorage.addMessage(userId, chatId!, userMessage);
    refreshChats();

    // Send to backend
    setIsLoading(true);
    setStreamingContent('');
    clientRef.current.sendMessage(content, activeChat?.id || null);
  }, [activeChat, userId]);

  // Handle HITL approval
  const handleApproval = useCallback((decision: 'approve' | 'reject', reason?: string) => {
    if (!clientRef.current || !pendingApproval || !activeChat) return;

    // Add approval action to messages
    const actionMessage: ChatMessage = {
      id: `action-${Date.now()}`,
      role: 'user',
      content: decision === 'approve'
        ? `Approved: ${pendingApproval.action}`
        : `Rejected: ${pendingApproval.action}${reason ? ` (${reason})` : ''}`,
      timestamp: new Date().toISOString(),
      metadata: {
        toolName: pendingApproval.tool_name,
        approved: decision === 'approve',
      },
    };
    chatStorage.addMessage(userId, activeChat.id, actionMessage);
    refreshChats();

    setIsLoading(true);
    clientRef.current.approve(decision, reason);
    setPendingApproval(null);
  }, [pendingApproval, activeChat, userId]);

  // Chat management
  const selectChat = useCallback((chatId: string) => {
    const chat = chats.find(c => c.id === chatId);
    if (chat) {
      setActiveChat(chat);
      chatStorage.setActiveChat(userId, chatId);
    }
  }, [chats, userId]);

  const startNewChat = useCallback(() => {
    setActiveChat(null);
    setStreamingContent('');
    setPendingApproval(null);
  }, []);

  const deleteChat = useCallback((chatId: string) => {
    chatStorage.deleteChat(userId, chatId);
    refreshChats();
    if (activeChat?.id === chatId) {
      setActiveChat(null);
    }
  }, [activeChat, userId]);

  const renameChat = useCallback((chatId: string, newTitle: string) => {
    chatStorage.updateChat(userId, chatId, { title: newTitle });
    refreshChats();
  }, [userId]);

  return {
    // Chat state
    chats,
    activeChat,
    messages: activeChat?.messages || [],

    // Connection state
    isConnected,
    isLoading,
    pendingApproval,
    streamingContent,

    // Actions
    sendMessage,
    handleApproval,

    // Chat management
    selectChat,
    startNewChat,
    deleteChat,
    renameChat,
  };
}
```

#### Update Main Chat Page Layout:

```typescript
// src/pages/LabeebChat.tsx
import { useLabeeb } from '../hooks/useLabeeb';
import { ChatSidebar } from '../components/ChatSidebar';
import { ChatMessages } from '../components/ChatMessages';
import { ChatInput } from '../components/ChatInput';
import { ApprovalModal } from '../components/ApprovalModal';
import { useAuth } from '../hooks/useAuth';  // Your auth hook

export function LabeebChat() {
  const { user, token } = useAuth();

  const {
    chats,
    activeChat,
    messages,
    isConnected,
    isLoading,
    pendingApproval,
    streamingContent,
    sendMessage,
    handleApproval,
    selectChat,
    startNewChat,
    deleteChat,
    renameChat,
  } = useLabeeb({
    baseUrl: import.meta.env.VITE_LABEEB_API_URL,
    token,
    userId: user?.id || 'anonymous',
  });

  return (
    <div className="flex h-screen bg-white dark:bg-gray-900">
      {/* Sidebar with past chats */}
      <ChatSidebar
        userId={user?.id || 'anonymous'}
        chats={chats}
        activeChatId={activeChat?.id || null}
        onSelectChat={selectChat}
        onNewChat={startNewChat}
        onDeleteChat={deleteChat}
        onRenameChat={renameChat}
      />

      {/* Main chat area */}
      <div className="flex-1 flex flex-col">
        {/* Header */}
        <div className="h-14 border-b flex items-center px-4 gap-2">
          <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
          <span className="font-medium">
            {activeChat?.title || 'New Chat'}
          </span>
        </div>

        {/* Messages */}
        <ChatMessages
          messages={messages}
          streamingContent={streamingContent}
          isLoading={isLoading}
        />

        {/* Input */}
        <ChatInput
          onSend={sendMessage}
          disabled={isLoading || !isConnected}
          placeholder={activeChat ? 'Continue the conversation...' : 'Start a new chat...'}
        />
      </div>

      {/* HITL Modal */}
      <ApprovalModal
        isOpen={!!pendingApproval}
        onApprove={() => handleApproval('approve')}
        onReject={(reason) => handleApproval('reject', reason)}
        {...pendingApproval}
      />
    </div>
  );
}
```

#### Storage Limits & Cleanup

```typescript
// Add to chat-storage.ts

const MAX_CHATS_PER_USER = 100;
const MAX_MESSAGES_PER_CHAT = 500;

// Call this periodically or on app load
cleanupOldChats(userId: string): void {
  const chats = this.getChats(userId);

  // Remove chats beyond limit (oldest first)
  if (chats.length > MAX_CHATS_PER_USER) {
    const toKeep = chats.slice(0, MAX_CHATS_PER_USER);
    this.saveChats(userId, toKeep);
  }

  // Trim messages in each chat
  chats.forEach(chat => {
    if (chat.messages.length > MAX_MESSAGES_PER_CHAT) {
      chat.messages = chat.messages.slice(-MAX_MESSAGES_PER_CHAT);
    }
  });
  this.saveChats(userId, chats);
}

// Get storage usage
getStorageUsage(userId: string): { chats: number; totalMessages: number; sizeKB: number } {
  const chats = this.getChats(userId);
  const totalMessages = chats.reduce((sum, c) => sum + c.messages.length, 0);
  const data = localStorage.getItem(this.getStorageKey(userId)) || '';
  const sizeKB = Math.round(new Blob([data]).size / 1024);

  return { chats: chats.length, totalMessages, sizeKB };
}
```

### Task 6: Environment Configuration

Create `.env.example`:

```bash
# Labeeb API Configuration
VITE_LABEEB_API_URL=https://your-agentcore-endpoint.amazonaws.com

# Cognito Configuration (if using direct auth)
VITE_COGNITO_USER_POOL_ID=eu-west-1_XlpCp8IVl
VITE_COGNITO_CLIENT_ID=2r07e1ep6il2qatbc9au7cq2bi
VITE_COGNITO_REGION=eu-west-1

# Optional: Feature flags
VITE_ENABLE_VOICE=false
VITE_ENABLE_CHARTS=true
```

---

## Part 5: Testing Checklist

### 5.1 Connection Tests
- [ ] WebSocket connects successfully
- [ ] Handles connection drops gracefully
- [ ] Reconnects automatically

### 5.2 Chat Flow Tests
- [ ] User message appears in feed
- [ ] Streaming tokens appear progressively
- [ ] Complete message rendered after stream ends
- [ ] Loading state shown during processing

### 5.3 HITL Tests
- [ ] Interrupt event shows approval modal
- [ ] Preview renders correctly (markdown support)
- [ ] Approve button sends correct message
- [ ] Reject button with reason works
- [ ] Agent resumes after approval

### 5.4 Session Tests
- [ ] Messages persist on page refresh
- [ ] Can switch between sessions
- [ ] New session starts clean
- [ ] Session history sidebar works

---

## Part 6: Agent Capabilities Reference

### Menu Agent Actions

| Action | Description | HITL Required |
|--------|-------------|---------------|
| `list_categories` | List all menu categories | No |
| `list_products` | List products (with filters) | No |
| `search_products` | Search products by name/SKU | No |
| `get_product_details` | Get single product info | No |
| `create_product` | Create new product | **Yes** |
| `update_product` | Update existing product | **Yes** |
| `delete_product` | Delete product | **Yes** |
| `list_modifiers` | List modifier groups | No |
| `create_modifier` | Create modifier group | **Yes** |

### Analytics Agent Actions

| Action | Description | HITL Required |
|--------|-------------|---------------|
| `list_customers` | List customers | No |
| `search_customers` | Search by name/phone | No |
| `get_orders` | Get order history | No |
| `sales_summary` | Sales analytics | No |
| `create_customer` | Create new customer | **Yes** |
| `blacklist_customer` | Blacklist customer | **Yes** |

---

## Part 7: Quick Reference

### AgentCore Endpoint (to be deployed)
```
Production: https://labeeb.bedrock-agentcore.eu-west-1.amazonaws.com
```

### Cognito Auth (team's infrastructure)
```
User Pool: eu-west-1_XlpCp8IVl
App Client: 2r07e1ep6il2qatbc9au7cq2bi
Region: eu-west-1
```

### WebSocket Message Types

| Client → Server | Description |
|-----------------|-------------|
| `message` | Send user message |
| `approve` | Approve/reject HITL action |
| `ping` | Keep-alive |

| Server → Client | Description |
|-----------------|-------------|
| `token` | Streaming text chunk |
| `interrupt` | HITL approval request |
| `approval_ack` | Confirms approval received, then streams continue |
| `complete` | Stream finished |
| `error` | Error occurred |
| `pong` | Keep-alive response |

---

## Summary for Replit

**What to do:**
1. Load Orbit repository into Replit
2. Create LabeebClient service (Task 1)
3. Create useLabeeb hook (Task 2)
4. Create ApprovalModal component (Task 3)
5. Modify OrbitAssistant to use real agent (Task 4)
6. **Implement Chat History Management (Task 5)** - CRITICAL
7. Configure environment (Task 6)

**Key files to create/modify:**
- `src/services/labeeb-api.ts` - WebSocket client
- `src/services/chat-storage.ts` - Local storage for chat history
- `src/hooks/useLabeeb.ts` - Main hook with chat management
- `src/components/ChatSidebar.tsx` - Past chats sidebar
- `src/components/ApprovalModal.tsx` - HITL confirmation
- `src/pages/LabeebChat.tsx` - Main chat page with sidebar layout

**Main differences from LangGraph Platform:**
- No `@langchain/langgraph-sdk` - use custom WebSocket client
- No `client.threads.create()` - session_id in messages
- No `Command({ resume })` - use `{ type: "approve" }` message
- JWT auth via Cognito, not API key

**IMPORTANT: Chat History is Frontend Responsibility**
```
┌─────────────────────────────────────────────────────────────┐
│  The backend does NOT store message history!                │
│                                                             │
│  Your frontend MUST:                                        │
│  1. Store all messages in localStorage (per user)          │
│  2. Display past chats in sidebar                          │
│  3. Allow switching between chats                          │
│  4. Manage chat lifecycle (create, delete, rename)         │
│  5. Send session_id to continue existing conversations     │
└─────────────────────────────────────────────────────────────┘
```
